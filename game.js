"use strict";var canvas;var program;var gl;var shaderFlag;var flag = true;var debug = false;var random = 0;//AABBvar heroPosition;var collision = false;  // If hero runs into objectvar collisionLocation_sphere = [maxObjects];   // An array of objects using sphere detectionvar collitionReady = false;// Arraysvar carMesh;var pointsArray = [];var normalsArray = [];var shapeArray = [];  // CUBE, SPHERE, CONE: [START, OFFset]var historyArray = [];var hero = [];var colorsArray = [];// Movementvar movementMatrix = vec3(0.0, 0.0, 0.0);  // When user moves// Rotate  Variablesvar xAxis = 0; var yAxis = 0; var zAxis = 0;  // Globalvar hxAxis = 0; var hyAxis = 0; var hzAxis = 0;  // Hero Rotation//   Perspectivevar near = 0.001;var far = 30.0;var radius = 5.0;var theta = 0;  // Radiansvar phi = 0.0;var dr = 10.0 * Math.PI / 180.0;// Aspect Ratiovar fovy = 45.0;  // Field-of-view in Y direction angle (in degrees)var aspect;       // Viewport aspect ratio// Model Viewvar mvMatrix;var pMatrix;var modelView;var projection;// Eyevar look;var eye;const at = vec3(0.0, 0.0, 0.0);const up = vec3(0.0, 1.0, 0.0);// Lightingvar ambientColor, diffuseColor, specularColor;// Lighting Colorvar red = 1.0;var green = 1.0;var blue = 1.0;var lightPosition = vec4(5.0, 0.0, 10.0, 0.0);var lightAmbient;var lightDiffuse;var lightSpecular;var materialAmbient = vec4(1.0, 1.0, 1.0, 1.0);var materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);var materialSpecular = vec4(1.0, 1.0, 1.0, 1.0);var materialShininess = 100.0;// Colorvar vertexColors = [    vec4(0.0, 0.0, 0.0, 1.0),  // black    vec4(1.0, 0.0, 0.0, 1.0),  // red    vec4(1.0, 1.0, 0.0, 1.0),  // yellow    vec4(0.0, 1.0, 0.0, 1.0),  // green    vec4(0.0, 0.0, 1.0, 1.0),  // blue    vec4(1.0, 0.0, 1.0, 1.0),  // magenta    vec4(0.0, 1.0, 1.0, 1.0),  // cyan    vec4(1.0, 1.0, 1.0, 1.0)  // white];window.onload = function init() {    ///////////////  INIT PROGRAM   //////////////////////    canvas = document.getElementById("gl-canvas");    gl = WebGLUtils.setupWebGL(canvas);    if (!gl) {        alert("WebGL isn't available");    }    gl.viewport(0, 0, canvas.width, canvas.height);    gl.clearColor(0.9, 0.9, 0.9, 1.0);    gl.enable(gl.DEPTH_TEST);    program = initShaders(gl, "light-shader", "fragment-shader");    gl.useProgram(program);    aspect = canvas.width / canvas.height;    //////////////////////////////////////////////////////////////////////////////////    ///////////////////////////////////////////////////////////////////////////////////    ///////////////////////////////////////////////////////////////////////////////////    ///////////////  DRAW SHAPES   //////////////////////    // Imported from Cube File    // Pass Draw Functions into helper function    shapeMapper(drawCube, pointsArray.length);    shapeMapper(drawSphere, pointsArray.length);    shapeMapper(drawCone, pointsArray.length);    ///////////////  IMPORT CAR   //////////////////////    /**     * Takes the car from the HTML file and parses the verticies from blender.     * Returns a object "carMesh" that has all of the arrays after parsing     *     * There are other functions in our third party library which can add the verticies to the     * buffer.  We should do this manuelly so that the code is not hidden     *     * After import.  We are adding the car to our shapes array so it matches the other objects.     * Shape array requrires and ARRAY of   [START, OFFSet]     *     * We still need to make a texture mapper.  Nick can finish the car.     */        // Add mesh verticies to our points array        // Give the car a shape ID    // var objStr = document.getElementById('car.obj').innerHTML;    // carMesh = new OBJ.Mesh(objStr);    //    // var start = pointsArray.length;    // var colorCount =0;    //    // // Convert from a flat array to an array holding vec4    // //  This is just so it matches the other objects    // //  Change if needed    // console.log(carMesh.indices);    // for(var i = 3; i < carMesh.vertices.length; i++){    //     pointsArray.push( vec4(carMesh.vertices[carMesh.indices[i]], carMesh.indices[i + 1], carMesh.indices[i + 2], 1.0  )  );    //     normalsArray.push( vec4(carMesh.vertexNormals[carMesh.indices[i]], carMesh.vertexNormals[carMesh.indices[i + 1]], carMesh.vertexNormals[carMesh.indices[i +2]], 1.0  )  );    //    //     //  Temp.  just so something shows up    //     colorsArray.push(vertexColors[colorCount]);    //     colorsArray.push(vertexColors[1 + colorCount]);    //     colorsArray.push(vertexColors[2 +colorCount]);    //     colorCount  =   ++colorCount % 3;    //    // }    // var offset = pointsArray.length - start;    // shapeArray.push([start, offset]);    // aabb_INIT();    /////////////////  PREPARE FOR RENDERING   //////////////////////    renderOrder();    ///////////////////////////////////////////////////////////////////////////////////    ///////////////////////////////////////////////////////////////////////////////////    ///////////////////////////////////////////////////////////////////////////////////    ///////////////  COLOR BUFFER   //////////////////////    var cBuffer = gl.createBuffer();    gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);    gl.bufferData(gl.ARRAY_BUFFER, flatten(colorsArray), gl.STATIC_DRAW);    var vColor = gl.getAttribLocation(program, "vColor");    gl.vertexAttribPointer(vColor, 4, gl.FLOAT, false, 0, 0);    gl.enableVertexAttribArray(vColor);    ///////////////  NORMAL VECTORS BUFFER   ///////////////    var nBuffer = gl.createBuffer();    gl.bindBuffer(gl.ARRAY_BUFFER, nBuffer);    gl.bufferData(gl.ARRAY_BUFFER, flatten(normalsArray), gl.STATIC_DRAW);    var vNormal = gl.getAttribLocation(program, "vNormal");    gl.vertexAttribPointer(vNormal, 3, gl.FLOAT, false, 0, 0);    gl.enableVertexAttribArray(vNormal);    ///////////////  VERTEX BUFFER   //////////////////////    var vBuffer = gl.createBuffer();    gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);    gl.bufferData(gl.ARRAY_BUFFER, flatten(pointsArray), gl.STATIC_DRAW);    var vPosition = gl.getAttribLocation(program, "vPosition");    gl.vertexAttribPointer(vPosition, 4, gl.FLOAT, false, 0, 0);    gl.enableVertexAttribArray(vPosition);    modelView = gl.getUniformLocation(program, "modelView");    projection = gl.getUniformLocation(program, "projection");    gl.uniform1f(gl.getUniformLocation(program, "shininess"), materialShininess);    updateLight();    updateLightPosition();    function updateLight() {        ///////////////  LIGHTING   //////////////////////        lightAmbient = vec4(red, green, blue, 1.0);        lightDiffuse = vec4(red, green, blue, 1.0);        lightSpecular = vec4(red, green, blue, 1.0);        var ambientProduct = mult(lightAmbient, materialAmbient);        var diffuseProduct = mult(lightDiffuse, materialDiffuse);        var specularProduct = mult(lightSpecular, materialSpecular);        gl.uniform4fv(gl.getUniformLocation(program, "ambientProduct"), flatten(ambientProduct));        gl.uniform4fv(gl.getUniformLocation(program, "diffuseProduct"), flatten(diffuseProduct));        gl.uniform4fv(gl.getUniformLocation(program, "specularProduct"), flatten(specularProduct));    }    function updateLightPosition() {        ///////////////  LIGHTING Position   //////////////////////        gl.uniform4fv(gl.getUniformLocation(program, "lightPosition"), flatten(lightPosition));    }    ///////////////  Buttons   //////////////////////    document.onkeydown = keydown;    function keydown(e) {        var speed = 0.3;        var rspeed =50 * speed;        e = e || window.event;        if (e.keyCode == '38') {  // up arrow            // Movement            if(!collision){                movementMatrix[0] += speed * Math.sin(theta);                movementMatrix[2] += speed *  Math.cos(theta);                // Object Rotation                hzAxis += rspeed *  Math.sin(theta);                hxAxis += rspeed *  Math.cos(theta);            }        }        else if (e.keyCode == '40') {  // down arrow            if(!collision){                // Movement                movementMatrix[0] -= speed * Math.sin(theta);                movementMatrix[2] -= speed *  Math.cos(theta);                // Object Rotation                hzAxis -= rspeed *  Math.sin(theta);                hxAxis -= rspeed *  Math.cos(theta);            }        }        else if (e.keyCode == '37') {  // left arrow            theta += dr;        }        else if (e.keyCode == '39') {  // right arrow            theta -= dr;        }    }    ///////////////  Mouse   //////////////////////    var gc = document.getElementById("gl-canvas");    /**     * This function move the "At" part of look at.     * The eye remains unchanged     */    gc.addEventListener("mousemove", function (event) {        // Do stuff    });    gc.addEventListener("mouseclick", function (event) {        // Do stuff    });    render();};var render = function () {    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    // CAMERA AND MODEL VIEW    eye = vec3(radius * Math.sin(theta) * Math.cos(phi), radius * Math.sin(theta) * Math.sin(phi), radius * Math.cos(theta));    look = lookAt(eye, at, up);    pMatrix = perspective(fovy, aspect, near, far);    // Rotation  Speed    xAxis += 0.5; // x axis    yAxis += 0.5;  // y axis    zAxis += 0.5;  // z axis    ///////////////  Render Objects   //////////////////////    /**     *     * Pull objects from the history array.     * Position 0 & 1 are default spheres     *     * arr[0]:  Type of shape, pulls from the shapes array.     *             CUBE, SPHERE, CONE: [START, OFF Set]     *             The shapes array represents each object by the     *             vertex start position and off set.     *             For example the cube might start at postion 0 and sphere at 36.     *             The cube's value will then be [0, 36] and represent positions     *             0 to 35.  Position 36 is where the cube starts     * arr[1]:  Flag for shader.  Passed into shader and represents if lighting is used.     * arr[2]:  Vec3:   Scale values for matrix multiplication     * arr[3]:  Vec3:   Translation values for matrix multiplication     * arr[4]:  Vec3:   Boolan Flag for rotation     *                  Each axis can rotate at different speeds.     *                  This flag determine which axis will be rotated.     */    // Hero Object    mvMatrix = mult(look, scalem(hero[2][0], hero[2][1], hero[2][2]));    mvMatrix = mult(mvMatrix, translate(hero[3]));    mvMatrix = mult(mvMatrix, rotateX(hxAxis));    mvMatrix = mult(mvMatrix, rotateY(hyAxis));    mvMatrix = mult(mvMatrix, rotateZ(hzAxis));    ////////////////////    AABB    //////////////////////////////    var aabb_matrix = mat4();    aabb_matrix = mult(aabb_matrix, scalem(hero[2][0], hero[2][1], hero[2][2]) );    aabb_matrix = mult(aabb_matrix, translate(hero[3]));    heroPosition = aabb_spherePosition(hero[0], aabb_matrix );    if(collitionReady){        for(var i = 0; i < collisionLocation_sphere.length; i++){            var results = aabb_sphere_sphere_detection(heroPosition, collisionLocation_sphere[i]);            if(results){                collision = results;  // We have detected a collision                break;            }        }    }    renderObject(shapeArray[ hero[0] ], hero[1], mvMatrix, pMatrix);    // // Random Object    var size = historyArray.length;    for (var i = 0; i < size; i++) {        var arr = historyArray[i];        var id = i;        var shape = arr[0];        var flag = arr[1];        var scaler = arr[2];        var trans = arr[3];        var axis = arr[4];        // False: Use Vertex Shader        // True: Use Light Shader        // Flag is passed into the shader as a float        var flagValue = 0.0;        if (flag) {            flagValue = 1.0;        }        /////////////////////////////////////////////////////////////////////        /////////////  MATRIX MULTIPLICATION ///////////////////////////////        // Look: Resets the position for each object        mvMatrix = mult(look, scalem(scaler[0], scaler[1], scaler[2]));        mvMatrix = matrixMult(mvMatrix, scaler, trans, axis);        ////////////////////    AABB    //////////////////////////////        var aabb_matrix = mat4();        aabb_matrix = matrixMult(aabb_matrix, scaler, trans, axis);        var position = aabb_spherePosition(shape, aabb_matrix );        collisionLocation_sphere[id] = position;        renderObject(shapeArray[shape], flagValue, mvMatrix, pMatrix);    }    /**     * Turns on collision detection system.     * We must get each objects location through the initial pass.     * We will store each objects location in arrays and processs the arrays     * when we process hereos.  We can add data structures to the arrays if we have a lot of objects     * @type {boolean}     */    collitionReady = true;  // turns on collision detec    requestAnimFrame(render);};function renderObject(indexArray, flagValue, mvMatrix, pMatrix) {    // All that work:  Lets Render!    gl.uniform1f(gl.getUniformLocation(program, "shaderFlag"), flagValue);    gl.uniformMatrix4fv(modelView, false, flatten(mvMatrix));    gl.uniformMatrix4fv(projection, false, flatten(pMatrix));    gl.drawArrays(gl.TRIANGLES, indexArray[0], indexArray[1]);}function matrixMult(matrix, scaler, trans, axis) {    /**     * Calculates the matrix for each object     * this is a sub-function     *     * 0:  Pass in the initial matrix     * 1:  Array int [3] of Scaler     * 2:  Array vec3  [2] Translation     * 3:  Array bool [3]:  Rotation for if statement     *     Speed is not parameter, that is global value *     Returns Matrix     *     */    matrix = mult(matrix, scalem(scaler[0], scaler[1], scaler[2]));    matrix = mult(matrix, translate(movementMatrix));    matrix = mult(matrix, translate(trans[0]));    if (axis[0])        matrix = mult(matrix, rotateX(xAxis));    if (axis[1])        matrix = mult(matrix, rotateY(yAxis));    if (axis[2])        matrix = mult(matrix, rotateZ(zAxis));    return mult(matrix, translate(trans[1]));}// Pass a function 'funk' which draws a shape// Map the starting point and offset to shapes arrayfunction shapeMapper(funk, startIndex) {    funk();    var offset = pointsArray.length - startIndex;    shapeArray.push([startIndex, offset]);}